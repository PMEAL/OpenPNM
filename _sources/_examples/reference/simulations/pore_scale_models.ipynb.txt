{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Pore Scale Models\n",
    "\n",
    "Pore scale models are one of the more important facets of OpenPNM, but they can be a bit confusing at first, since they work 'behind-the-scenes'.  \n",
    "They offer 3 main advantages, in order: \n",
    "\n",
    "1. They allow automatic regeneration of all dependent properties when something 'upstream' is changed.\n",
    "1. A large library of pre-written models is included and they can be mixed together and their parameters edited to get a desired overall result.\n",
    "1. The pore-scale model machinery was designed to allow easy use of custom written code for cases where a prewritten model is not available. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The best way to explain their importance is via illustration.  \n",
    "\n",
    "Consider a fluid flow simulation, where the hydraulic conductance is defined as:\n",
    "\n",
    "$$ g_H = \\frac{\\pi R^4}{8 \\mu L} $$\n",
    "\n",
    "The viscosity can be predicted using a correlation:\n",
    "\n",
    "$$ \\mu = ? $$\n",
    "\n",
    "Now say you want to re-run the simulation at different temperature.  This would require recalculating $\\mu$, followed by updating the hydraulic conductance.\n",
    "\n",
    "Using pore-scale models in OpenPNM allows for simple and reliable updating of these properties, for instance within a for-loop where temperature is being varied.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Using Existing Pore-Scale Models\n",
    "\n",
    "OpenPNM includes a library of pre-written models, so let's start by using an existing model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:31.334208Z",
     "iopub.status.busy": "2021-06-24T11:25:31.332749Z",
     "iopub.status.idle": "2021-06-24T11:25:31.925227Z",
     "shell.execute_reply": "2021-06-24T11:25:31.923818Z"
    }
   },
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "np.random.seed(0)\n",
    "import openpnm as op\n",
    "pn = op.network.Demo(shape=[5, 5, 1], spacing=1e-4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we need to define the gas phase diffusivity.  We can fetch the ``fuller`` model from the ``models`` library to do this, and attach it to an empty phase object:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:31.933560Z",
     "iopub.status.busy": "2021-06-24T11:25:31.932119Z",
     "iopub.status.idle": "2021-06-24T11:25:31.935015Z",
     "shell.execute_reply": "2021-06-24T11:25:31.936243Z"
    }
   },
   "outputs": [],
   "source": [
    "water = op.phase.Phase(network=pn)\n",
    "f = op.models.phase.viscosity.water_correlation\n",
    "water.add_model(propname='pore.viscosity', model=f)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We have used the ``water_correlation`` model, which is a polynomial fit specfically to the properties of water as a function temperature (and salinity if relevant)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Next we need to define the hydraulic conductance, which is also available in the model libary:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:31.954627Z",
     "iopub.status.busy": "2021-06-24T11:25:31.948791Z",
     "iopub.status.idle": "2021-06-24T11:25:31.960890Z",
     "shell.execute_reply": "2021-06-24T11:25:31.959749Z"
    }
   },
   "outputs": [],
   "source": [
    "f = op.models.physics.hydraulic_conductance.generic_hydraulic\n",
    "water.add_model(propname='throat.hydraulic_conductance', model=f)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lastly we can run the StokesFlow algorithm to get the flow rate across the domain for a given set of pressure boundary conditions:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:31.972880Z",
     "iopub.status.busy": "2021-06-24T11:25:31.971479Z",
     "iopub.status.idle": "2021-06-24T11:25:32.111655Z",
     "shell.execute_reply": "2021-06-24T11:25:32.112431Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1.46458816e-13]                                                                                                       \n"
     ]
    }
   ],
   "source": [
    "sf = op.algorithms.StokesFlow(network=pn, phase=water)\n",
    "sf.set_value_BC(pores=pn.pores('left'), values=1)\n",
    "sf.set_value_BC(pores=pn.pores('right'), values=0)\n",
    "sf.run()\n",
    "print(sf.rate(pores=pn.pores('left')))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Changing dependent properties\n",
    "\n",
    "Now consider that you want to find the diffusion rate at higher temperature.  This requires recalculating the diffusion coefficient on ``air``, then updating the diffusive conductivity on ``phys``, and finally re-running the simulation.  Using pore-scale models this can be done as follows:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.167731Z",
     "iopub.status.busy": "2021-06-24T11:25:32.167066Z",
     "iopub.status.idle": "2021-06-24T11:25:32.169807Z",
     "shell.execute_reply": "2021-06-24T11:25:32.170332Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Viscosity before changing temperaure: 0.000893190947459112\n",
      "Viscosity after: 0.000893190947459112\n"
     ]
    }
   ],
   "source": [
    "print('Viscosity before changing temperaure:', water['pore.viscosity'][0])\n",
    "water['pore.temperature'] = 353.0\n",
    "water.regenerate_models()\n",
    "print('Viscosity after:', water['pore.viscosity'][0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can see that the viscosity decreased with temperature as expected.  We can also propagate this change to the diffusive conductance:"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "And lastly we can recalculate the flow rate:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.186817Z",
     "iopub.status.busy": "2021-06-24T11:25:32.186185Z",
     "iopub.status.idle": "2021-06-24T11:25:32.197590Z",
     "shell.execute_reply": "2021-06-24T11:25:32.198115Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1.46458816e-13]                                                                                                       \n"
     ]
    }
   ],
   "source": [
    "sf.run()\n",
    "print(sf.rate(pores=pn.pores('left')))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Updating parameter on an existing model\n",
    "\n",
    "It's also easy to change parameters of a model since they are all stored on the object (``water`` in this case), meaning you don't have to reassign a new model get new parameters (although that would work).  The models and their parameters are stored under the ``models`` attribute of each object.  This is a dictionary with each model stored under the key match the ``propname`` to which is was assigned. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.119402Z",
     "iopub.status.busy": "2021-06-24T11:25:32.118708Z",
     "iopub.status.idle": "2021-06-24T11:25:32.122157Z",
     "shell.execute_reply": "2021-06-24T11:25:32.121557Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Diffusivity before changing parameter: 2.067547836430591e-05\n",
      "Diffusivity after: 2.0969679602405972e-05\n"
     ]
    }
   ],
   "source": [
    "print('Diffusivity before changing parameter:', air['pore.diffusivity'][0])\n",
    "air.models['pore.diffusivity']['vA'] = 15.9\n",
    "air.regenerate_models()\n",
    "print('Diffusivity after:', air['pore.diffusivity'][0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Replacing an existing model with another\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's say for some reason that the Fuller model is not suitable.  It's easy to go 'shopping' in the models library to retrieve a new model and replace the existing one.  In the cell below we grab the Chapman-Enskog model and simply assign it to the same ``propname`` that the Fuller model was previously."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.128203Z",
     "iopub.status.busy": "2021-06-24T11:25:32.127508Z",
     "iopub.status.idle": "2021-06-24T11:25:32.131548Z",
     "shell.execute_reply": "2021-06-24T11:25:32.130955Z"
    }
   },
   "outputs": [
    {
     "ename": "KeyError",
     "evalue": "'molecular_weight'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyError\u001b[0m                                  Traceback (most recent call last)",
      "\u001b[1;32m~\\AppData\\Local\\Temp/ipykernel_5216/3435646099.py\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mf\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mop\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmodels\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mphase\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mviscosity\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mliquid_pure_ls\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mwater\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0madd_model\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mpropname\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'pore.viscosity'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmodel\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mf\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[0mprint\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Diffusivity after:'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mwater\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;34m'pore.diffusivity'\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;36m0\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\jeff\\dropbox\\flash sync\\code\\git\\openpnm\\openpnm\\core\\_base2.py\u001b[0m in \u001b[0;36madd_model\u001b[1;34m(self, propname, model, domain, regen_mode, **kwargs)\u001b[0m\n\u001b[0;32m    479\u001b[0m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmodels\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mpropname\u001b[0m\u001b[1;33m+\u001b[0m\u001b[1;34m'@'\u001b[0m\u001b[1;33m+\u001b[0m\u001b[0mdomain\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mModelWrapper\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    480\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mregen_mode\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[1;34m'deferred'\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 481\u001b[1;33m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrun_model\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mpropname\u001b[0m\u001b[1;33m+\u001b[0m\u001b[1;34m'@'\u001b[0m\u001b[1;33m+\u001b[0m\u001b[0mdomain\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    482\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    483\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0madd_model_collection\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmodels\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mregen_mode\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'deferred'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdomain\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m'all'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\jeff\\dropbox\\flash sync\\code\\git\\openpnm\\openpnm\\core\\_base2.py\u001b[0m in \u001b[0;36mrun_model\u001b[1;34m(self, propname, domain)\u001b[0m\n\u001b[0;32m    514\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[1;34m'@'\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mpropname\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# Get domain from propname if present\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    515\u001b[0m                 \u001b[0mpropname\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdomain\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mpropname\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msplit\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'@'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 516\u001b[1;33m                 \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrun_model\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mpropname\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mpropname\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdomain\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mdomain\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    517\u001b[0m             \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# No domain means run model for ALL domains\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    518\u001b[0m                 \u001b[1;32mfor\u001b[0m \u001b[0mitem\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmodels\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mkeys\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\jeff\\dropbox\\flash sync\\code\\git\\openpnm\\openpnm\\core\\_base2.py\u001b[0m in \u001b[0;36mrun_model\u001b[1;34m(self, propname, domain)\u001b[0m\n\u001b[0;32m    533\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[1;34m'domain'\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[1;32min\u001b[0m \u001b[0minspect\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mgetfullargspec\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmod_dict\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;34m'model'\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    534\u001b[0m                 \u001b[0m_\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mkwargs\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpop\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'domain'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 535\u001b[1;33m                 \u001b[0mvals\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mmod_dict\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;34m'model'\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    536\u001b[0m                 \u001b[1;32mif\u001b[0m \u001b[0misinstance\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mvals\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdict\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# Handle models that return a dict\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    537\u001b[0m                     \u001b[1;32mfor\u001b[0m \u001b[0mk\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mv\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mvals\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mitems\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\jeff\\dropbox\\flash sync\\code\\git\\openpnm\\openpnm\\models\\phase\\viscosity\\_funcs.py\u001b[0m in \u001b[0;36mliquid_pure_ls\u001b[1;34m(phase, T, MW, Tc, Pc, omega)\u001b[0m\n\u001b[0;32m    268\u001b[0m     \u001b[1;31m# Letsou_Stiel\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    269\u001b[0m     \u001b[0mT\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mphase\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mT\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 270\u001b[1;33m     \u001b[0mMW\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mphase\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mMW\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    271\u001b[0m     \u001b[0mTc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mphase\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mTc\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    272\u001b[0m     \u001b[0mPc\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mphase\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mPc\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mc:\\users\\jeff\\dropbox\\flash sync\\code\\git\\openpnm\\openpnm\\phase\\_phase.py\u001b[0m in \u001b[0;36m__getitem__\u001b[1;34m(self, key)\u001b[0m\n\u001b[0;32m     73\u001b[0m         \u001b[1;31m# Get params directly if appropriate\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     74\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0melement\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;34m'param'\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 75\u001b[1;33m             \u001b[1;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mparams\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mprop\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     76\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     77\u001b[0m         \u001b[1;31m# Next get the data arrays, this is the case if @ notation was used\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mKeyError\u001b[0m: 'molecular_weight'"
     ]
    }
   ],
   "source": [
    "f = op.models.phase.viscosity.liquid_pure_ls\n",
    "water.add_model(propname='pore.viscosity', model=f)\n",
    "print('Diffusivity after:', water['pore.diffusivity'][0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note that we don't need to explicitly call ``regenerate_models`` since this occurs automatically when a model is added.  We do however, have to regenerate ``phys`` object so it calculates the diffusive conductance with the new diffusivity:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.140014Z",
     "iopub.status.busy": "2021-06-24T11:25:32.139367Z",
     "iopub.status.idle": "2021-06-24T11:25:32.161585Z",
     "shell.execute_reply": "2021-06-24T11:25:32.162114Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[1.03738023e-10]\n"
     ]
    }
   ],
   "source": [
    "phys.regenerate_models()\n",
    "fd.reset()\n",
    "fd.run()\n",
    "print(fd.rate(pores=pn.pores('left')))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Creating Custom Models\n",
    "\n",
    "Lastly, let's illustrate the ease with which a custom pore-scale model can be defined and used.  Let's create a very basic (and incorrect) model:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.202961Z",
     "iopub.status.busy": "2021-06-24T11:25:32.202310Z",
     "iopub.status.idle": "2021-06-24T11:25:32.204196Z",
     "shell.execute_reply": "2021-06-24T11:25:32.204717Z"
    }
   },
   "outputs": [],
   "source": [
    "def new_diffusivity(target, A, B, \n",
    "                    temperature='pore.temperature', \n",
    "                    pressure='pore.pressure'):\n",
    "    T = target[temperature]\n",
    "    P = target[pressure]\n",
    "    DAB = A*T**3/(P*B)\n",
    "    return DAB"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are a few key points to note in the above code.  \n",
    "\n",
    "1. Every model must accept a ``target`` argument since the ``regenerate_models`` mechanism assumes it is present.  The ``target`` is the object to which the model will be attached.  It allows for the looking up of necessary properties that should already be defined, like temperature and pressure.  Even if you don't use ``target`` within the function it is still required by the pore-scale model mechanism.  If it's presence annoys you, you can put a ``**kwargs`` at the end of the argument list to accept all arguments that you don't explicitly need.  \n",
    "2. The input parameters should not be arrays (like an Np-long list of temperature values).  Instead you should pass the dictionary key of the values on the ``target``.  This allows the model to lookup the latest values for each property when ``regenerate_models`` is called.  This also enables openpnm to store the model parameters as short strings rather than large arrays.\n",
    "3. The function should return either a scalar value or an array of Np or Nt length.  In the above case it returns a DAB value for each pore, depending on its local temperature and pressure in the pore.  However, if the ``temperature`` were set to ``'throat.temperature'`` and ``pressure`` to ``'throat.pressure'``, then the above function would return a DAB value for each throat and it could be used to calculate ``'throat.diffusivity'``.\n",
    "4. This function can be placed at the top of the script in which it is used, or it can be placed in a separate file and imported into the script with ``from my_models import new_diffusivity``."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's add this model to our ``air`` phase and inspect the new values:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:32.210180Z",
     "iopub.status.busy": "2021-06-24T11:25:32.209519Z",
     "iopub.status.idle": "2021-06-24T11:25:32.211859Z",
     "shell.execute_reply": "2021-06-24T11:25:32.212390Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2.06722719e-05 2.06722719e-05 2.06722719e-05 2.06722719e-05\n",
      " 2.06722719e-05 2.06722719e-05 2.06722719e-05 2.06722719e-05\n",
      " 2.06722719e-05 2.06722719e-05 2.06722719e-05 2.06722719e-05\n",
      " 2.06722719e-05 2.06722719e-05 2.06722719e-05 2.06722719e-05\n",
      " 2.06722719e-05 2.06722719e-05 2.06722719e-05 2.06722719e-05\n",
      " 2.06722719e-05 2.06722719e-05 2.06722719e-05 2.06722719e-05\n",
      " 2.06722719e-05]\n"
     ]
    }
   ],
   "source": [
    "air.add_model(propname='pore.diffusivity',\n",
    "              model=new_diffusivity,\n",
    "              A=1e-6, B=21)\n",
    "print(air['pore.diffusivity'])"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": false,
   "sideBar": true,
   "skip_h1_title": true,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": true,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
