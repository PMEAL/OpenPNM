{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Storage of Network Data and Topology\n",
    "\n",
    "As discussed in the first tutorial, OpenPNM uses Numpy ``ndarrays`` to store all data, and these arrays store all stored in ``dict``s, because all OpenPNM objects are subclassed python dictionaries. In this tutorial will take a deper dive into the details of the OpenPNM data storage scheme. The sections to be covered are:\n",
    "\n",
    "| Subject |\n",
    "| :- |\n",
    "| The Spreadsheet Analogy |\n",
    "| Maintaining Data Integrity |\n",
    "| Representing Topology |"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Spreadsheet Analogy\n",
    "\n",
    "The best analogy for explaining data storage in OpenPNM is the humble spreadsheet.  According to this analogy you can imagine all data is stored in a table; two tables actually, one for pore data and one for throat data.  Each pore (or throat) corresponds to a row and each property corresponds to a column.  Consider the following network with 4 pores, 3 throats:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import openpnm as op\n",
    "import numpy as np\n",
    "np.random.seed(0)\n",
    "pn = op.network.Demo(shape=[4, 1, 1])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Let's use [pandas](https://pandas.pydata.org/) to express the geometric properties as a 'spreadsheet' and pull out all pore properties that are are a single column wide"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "pore_data_sheet = pd.DataFrame({k: pn[k] for k in pn.props(element='pore') if pn[k].ndim == 1})"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now view this 'spreadsheet':"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>pore.coordination_number</th>\n",
       "      <th>pore.diameter</th>\n",
       "      <th>pore.max_size</th>\n",
       "      <th>pore.seed</th>\n",
       "      <th>pore.volume</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>1.0</td>\n",
       "      <td>0.474407</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.474407</td>\n",
       "      <td>0.055905</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>2.0</td>\n",
       "      <td>0.557595</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.557595</td>\n",
       "      <td>0.090773</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>2.0</td>\n",
       "      <td>0.501382</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.501382</td>\n",
       "      <td>0.065994</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>1.0</td>\n",
       "      <td>0.472442</td>\n",
       "      <td>1.0</td>\n",
       "      <td>0.472442</td>\n",
       "      <td>0.055213</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "   pore.coordination_number  pore.diameter  pore.max_size  pore.seed  \\\n",
       "0                       1.0       0.474407            1.0   0.474407   \n",
       "1                       2.0       0.557595            1.0   0.557595   \n",
       "2                       2.0       0.501382            1.0   0.501382   \n",
       "3                       1.0       0.472442            1.0   0.472442   \n",
       "\n",
       "   pore.volume  \n",
       "0     0.055905  \n",
       "1     0.090773  \n",
       "2     0.065994  \n",
       "3     0.055213  "
      ]
     },
     "execution_count": 3,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pore_data_sheet"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The column names are the properties such as **pore.volume**, and the rows correspond to the pore index, so pore ``0`` has a volume of 0.055905.  "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "One could also extract an entire column using:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.060457Z",
     "iopub.status.busy": "2021-06-24T11:25:06.059315Z",
     "iopub.status.idle": "2021-06-24T11:25:06.063503Z",
     "shell.execute_reply": "2021-06-24T11:25:06.064416Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0    0.055905\n",
      "1    0.090773\n",
      "2    0.065994\n",
      "3    0.055213\n",
      "Name: pore.volume, dtype: float64\n"
     ]
    }
   ],
   "source": [
    "column = pore_data_sheet['pore.volume']\n",
    "print(column)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Or access individual elements:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.071219Z",
     "iopub.status.busy": "2021-06-24T11:25:06.070328Z",
     "iopub.status.idle": "2021-06-24T11:25:06.075321Z",
     "shell.execute_reply": "2021-06-24T11:25:06.074525Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "0.05590507143096387\n"
     ]
    }
   ],
   "source": [
    "print(pore_data_sheet['pore.volume'][0])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> âš  **Warning**\n",
    ">\n",
    "> The spreadsheet analogy is very apt, but it breaks down slightly when one considers data that is multiple colums wide such as **'pore.coords'**.  The is stored as an Np-by-3 array in the network dictionary, but spreadsheets usually require that all data is only a single column wide. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Rules to Maintain Data Integrity\n",
    "\n",
    "Several rules have been implemented to control the integrity of the data. This is implemented by subclassing the `__setitem__` method of the the `dict`. Each time data is assigned to a dictionary key, OpenPNM first checks the data type and dictionary key to ensure the rules are followed.  Each of these checks are explored below.\n",
    "\n",
    "#### All Values are Converted to Numpy Arrays\n",
    "Only Numpy arrays can be stored in an OpenPNM object, and any data that is written to an OpenPNM object (i.e. dictionary) will be converted to a Numpy array.  This is done to ensure that all mathematical operations throughout the code can be consistently done using vectorization. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.176510Z",
     "iopub.status.busy": "2021-06-24T11:25:06.175396Z",
     "iopub.status.idle": "2021-06-24T11:25:06.180431Z",
     "shell.execute_reply": "2021-06-24T11:25:06.181503Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "<class 'numpy.ndarray'>\n"
     ]
    }
   ],
   "source": [
    "pn['throat.list'] = [1, 2, 3]\n",
    "print(type(pn['throat.list']))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This illustrates that the basic python list-type has been converted to a Numpy array when stored in the dictionary"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Dictionary Keys Must Start With 'pore' or 'throat'\n",
    "All array names must begin with either *'pore.'* or *'throat.'* which serves to identify the type of information they contain."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.204358Z",
     "iopub.status.busy": "2021-06-24T11:25:06.203478Z",
     "iopub.status.idle": "2021-06-24T11:25:06.208127Z",
     "shell.execute_reply": "2021-06-24T11:25:06.208790Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This will throw an exception since the dict name cannot start with foo\n"
     ]
    }
   ],
   "source": [
    "try:\n",
    "    pn['foo.bar'] = 0\n",
    "except:\n",
    "    print('This will throw an exception since the dict name cannot start with foo')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The pore or throat prefix is enforced so that OpenPNM knows how long an array should be. Attempting to write an array of the wrong length will result in a error:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "This will throw an exception since there are 4 pores, hence all pore arrays should be 4 elements long\n"
     ]
    }
   ],
   "source": [
    "try:\n",
    "    pn['pore.test'] = [0, 0, 0]\n",
    "except:\n",
    "    print('This will throw an exception since there are 4 pores, hence all pore arrays should be 4 elements long')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Any Scalars are Expanded to a Full-Length Vector\n",
    "For the sake of consistency only arrays of length *Np* or *Nt* are allowed in the dictionary. Assigning a scalar value to a dictionary results in the creation of a full length vector, either *Np* or *Nt* long, depending on the name of the array. This effectively applies the scalar value to all locations in the network."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.191724Z",
     "iopub.status.busy": "2021-06-24T11:25:06.190288Z",
     "iopub.status.idle": "2021-06-24T11:25:06.195032Z",
     "shell.execute_reply": "2021-06-24T11:25:06.196182Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0 0 0 0]\n"
     ]
    }
   ],
   "source": [
    "pn['pore.test'] = 0\n",
    "print(pn['pore.test'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Note how the scalar value has been cast to an array of 4 elements long, one for each pore in the network. "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Nested Dictionary Names are Allowed\n",
    "It's possible to create nested properties by assigning a dictionary containing numpy arrays"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.218609Z",
     "iopub.status.busy": "2021-06-24T11:25:06.217483Z",
     "iopub.status.idle": "2021-06-24T11:25:06.222264Z",
     "shell.execute_reply": "2021-06-24T11:25:06.223411Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'species_A': array([0, 0, 0, 0]), 'species_B': array([1, 1, 1, 1])}\n"
     ]
    }
   ],
   "source": [
    "pn['pore.concentration'] = {'species_A': 0, 'species_B': 1}\n",
    "print(pn['pore.concentration'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The above rule about expanding the scalar values to a numpy array have been applied.  \n",
    "\n",
    "Requesting the top level of dictionary key returns both concentrations, but they can accessed directly too:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.231472Z",
     "iopub.status.busy": "2021-06-24T11:25:06.230502Z",
     "iopub.status.idle": "2021-06-24T11:25:06.235503Z",
     "shell.execute_reply": "2021-06-24T11:25:06.236221Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0 0 0 0]\n"
     ]
    }
   ],
   "source": [
    "print(pn['pore.concentration.species_A'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can also retreive a dictionary by requesting only the element ('pore' or 'throat') and the propname ('concentration'):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.244270Z",
     "iopub.status.busy": "2021-06-24T11:25:06.243340Z",
     "iopub.status.idle": "2021-06-24T11:25:06.248217Z",
     "shell.execute_reply": "2021-06-24T11:25:06.249026Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'species_A': array([0, 0, 0, 0]), 'species_B': array([1, 1, 1, 1])}"
      ]
     },
     "execution_count": 13,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pn['pore.concentration']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The above retuns a 'subdictionary' which can be indexed into:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0, 0, 0, 0])"
      ]
     },
     "execution_count": 14,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pn['pore.concentration']['species_A']"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Boolean Arrays are Treated as Labels, Numerical Arrays are Treated as Properties\n",
    "Any Boolean data will be treated as a *label* while all other numerical data is treated as a *property*. OpenPNM uses *labels* extensively as will be illustrated in a later tutorial. For this tutorial, we'll just introduce the idea.  We can create a new label by assigning `False` to a new key. This will expand the single `False` value into every pore, which means that NO pores have that label (yet):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.257992Z",
     "iopub.status.busy": "2021-06-24T11:25:06.256769Z",
     "iopub.status.idle": "2021-06-24T11:25:06.261857Z",
     "shell.execute_reply": "2021-06-24T11:25:06.262995Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['pore.all', 'pore.label', 'pore.left', 'pore.right', 'pore.surface']\n"
     ]
    }
   ],
   "source": [
    "pn['pore.label'] = False\n",
    "print(pn.labels(element='pore'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "You can see that ``'pore.label'`` shows up in this list automatically since it is of Boolean type. However, if you ask the network which pores have that label, the answer is none:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([], dtype=int32)"
      ]
     },
     "execution_count": 16,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pn.pores('label')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "If we then set some locations to `True`, this will change:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0 1 2]\n"
     ]
    }
   ],
   "source": [
    "pn['pore.label'][[0, 1, 2]] = True\n",
    "print(pn.pores('label'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "OpenPNM objects include a method for creating a label and applying it to locations all in one step using the `set_label` method."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[2 3]\n"
     ]
    }
   ],
   "source": [
    "pn.set_label('another', pores=[2, 3])\n",
    "print(pn.pores('another'))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Dictionary Keys with a Leading Underscore are Hidden\n",
    "Following the Python convention, if a piece of data is not really meant to be seen or used by the user, it can be pre-pended with an underscore and it will no appear in any output."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.271759Z",
     "iopub.status.busy": "2021-06-24T11:25:06.270788Z",
     "iopub.status.idle": "2021-06-24T11:25:06.275494Z",
     "shell.execute_reply": "2021-06-24T11:25:06.276273Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n",
      "1     : pore.concentration.species_A\n",
      "2     : pore.concentration.species_B\n",
      "3     : pore.coordination_number\n",
      "4     : pore.coords\n",
      "5     : pore.diameter\n",
      "6     : pore.max_size\n",
      "7     : pore.seed\n",
      "8     : pore.test\n",
      "9     : pore.volume\n",
      "10    : throat.conns\n",
      "11    : throat.cross_sectional_area\n",
      "12    : throat.diameter\n",
      "13    : throat.diffusive_size_factors\n",
      "14    : throat.hydraulic_size_factors\n",
      "15    : throat.length\n",
      "16    : throat.list\n",
      "17    : throat.max_size\n",
      "18    : throat.spacing\n",
      "19    : throat.volume\n",
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
     ]
    }
   ],
   "source": [
    "pn['pore._hidden'] = 1\n",
    "print(pn.props())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The ``'pore._hidden'`` key does not show up in this list, though it is present:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([1, 1, 1, 1])"
      ]
     },
     "execution_count": 20,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pn['pore._hidden']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "True\n"
     ]
    }
   ],
   "source": [
    "print('pore._hidden' in pn.keys())"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## The `param` prefix\n",
    "\n",
    "Expanding all scalar values to arrays that are either Np or Nt long is done as a convenience or shorthand to mean \"place this value of X in all pores\". This them means that you can later ask \"what is the value of X in pore Y\" and get an answer. This implies that X might take on different values in each pore/throat. However, there are properties which we know are constant, such as the molecular weight or critical temperature of a pure species. In V3 we have introduced the `params` attribute to all object, such that `pn.params` is a dictionary containing such scalar values. For convenience we have also added the ability to read and write to the `params` dictionary via the main get/set method. This is illustrated below:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n",
      "Parameters                          Value\n",
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n",
      "lattice_connectivity                6\n",
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
     ]
    }
   ],
   "source": [
    "pn.params['lattice_connectivity'] = 6\n",
    "print(pn.params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "> ProTip: Use the \"param\" prefix\n",
    ">\n",
    "> It is possible use the `param` prefix when reading and writing to the object's dictionary. This intercepts the given key and dispatches the request to the `params` attribute. This feature is particularly useful when passing arguments to pore-scale models (to be discussed in a later tutorial) since you can pass either `arg='param.value'` or `arg='pore.value'` and OpenPNM will be able to fetch the requested data by doing `value = pn[arg]` and both options will work."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n",
      "Parameters                          Value\n",
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n",
      "lattice_connectivity                6\n",
      "test                                2\n",
      "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
     ]
    }
   ],
   "source": [
    "pn['param.test'] = 2\n",
    "print(pn.params)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Representing Topology\n",
    "\n",
    "Topology was introduced in the last tutorial, but not discussed to \n",
    "\n",
    "Consider the following simple random network:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.285814Z",
     "iopub.status.busy": "2021-06-24T11:25:06.284955Z",
     "iopub.status.idle": "2021-06-24T11:25:06.303321Z",
     "shell.execute_reply": "2021-06-24T11:25:06.304283Z"
    }
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<matplotlib.collections.PathCollection at 0x13aac6821c0>"
      ]
     },
     "execution_count": 26,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 360x1019.05 with 1 Axes>"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "np.random.seed(0)\n",
    "pn = op.network.Delaunay(points=4, shape=[1, 1, 0])\n",
    "op.topotools.plot_tutorial(pn)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The basic premise of how OpenPNM stores topology can be stated in 1 sentence:\n",
    "\n",
    "**The pores on either end of a throat are just another property to be stored, along with diameter, length, etc.**\n",
    "\n",
    "In other words, referring to the above diagram, throat No. 5 has pores 1 and 4 on it's ends.  Using the spreadsheet analogy, this implies a new colunm that stores the pair of pores connected by each throat.  OpenPNM calls this property ``'throat.conns'``: "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "metadata": {
    "execution": {
     "iopub.execute_input": "2021-06-24T11:25:06.713161Z",
     "iopub.status.busy": "2021-06-24T11:25:06.712287Z",
     "iopub.status.idle": "2021-06-24T11:25:06.715218Z",
     "shell.execute_reply": "2021-06-24T11:25:06.715912Z"
    }
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[[0 1]\n",
      " [0 2]\n",
      " [0 3]\n",
      " [1 3]\n",
      " [2 3]]\n"
     ]
    }
   ],
   "source": [
    "print(pn['throat.conns'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Inspection of this *Nt-by-2* array shows that each row contains the pore indices corresponding to that throat."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Sparse Adjacency Matrices\n",
    "\n",
    "The topology storage scheme described above is actually an [adjacency matrix](http://en.wikipedia.org/wiki/Adjacency_matrix), in a [sparse storage format](http://en.wikipedia.org/wiki/Sparse_matrix) known as IJV or COO.  \n",
    "\n",
    "An adjacency matrix is a *Np*-by-*Np* matrix with non-zero values at location (*i*, *j*) indicating that pores *i* and *j* are connected.  \n",
    "\n",
    "An important feature of the adjacency matrix is that it is highly sparse (mostly zeros) and can be stored with a variety of [sparse storage schemes](https://docs.scipy.org/doc/scipy/reference/sparse.html) offered by Scipy.  OpenPNM stores the adjacency matrix in the 'COO' format, which essentially stores the coordinates (I,J) of the nonzero elements in an two-colume wide array.\n",
    "\n",
    "Thus the throat property called ``'throat.conns'`` is an *Nt*-by-2 array that gives the index of the two pores on either end of a given throat.  \n",
    "\n",
    "#### Additional Thoughts on Sparse Storage\n",
    "\n",
    "* In pore networks there is (usually) no difference between traversing from pore *i* to pore *j* or from pore *j* to pore *i*, so a 1 is also found at location (*j*, *i*) and the matrix is symmetrical.\n",
    "\n",
    "* Since the adjacency matrix is symmetric, it is redundant to store the entire matrix when only the upper triangular part is necessary.  The ``'throat.conns'`` array only stores the upper triangular information, and *i* is always less than *j*.\n",
    "\n",
    "* Although this storage scheme is widely known as *IJV*, the ``scipy.sparse`` module calls this the Coordinate or *COO* storage scheme.\n",
    "\n",
    "* Some tasks are best performed on other types of storages scheme, such as *CSR* or *LIL*.  OpenPNM converts between these internally as necessary, but users can generate a desired format using the ``create_adjacency_matrix`` method which accepts the storage type as an argument (i.e. ``'csr'``, ``'lil'``, etc).  For a discussion of sparse storage schemes and the respective merits, see this [Wikipedia article](http://en.wikipedia.org/wiki/Sparse_matrix)."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Topology Rules\n",
    "\n",
    "OpenPNM requires that the following be true about the network:\n",
    "\n",
    "1. A throat is a connection between exactly two pores, no more and no less\n",
    "\n",
    "2. Throats are non-directional, meaning that flow in either direction is equal\n",
    "\n",
    "Other general, but non-essential rules are:\n",
    "\n",
    "3. Pores can have an arbitrary number of throats, including zero; however, pores with zero throats lead to singular matrices and other problems so should be avoided.\n",
    "\n",
    "4. Two pores are generally connected by no more than one throat.  It is technically possible in OpenPNM to have multiple throats between a pair of pores, but it is not rigorosly supported so unintended results may arise."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "@webio": {
   "lastCommId": null,
   "lastKernelId": null
  },
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": false,
   "sideBar": true,
   "skip_h1_title": true,
   "title_cell": "",
   "title_sidebar": "Contents",
   "toc_cell": true,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
