{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "38d84418",
   "metadata": {},
   "source": [
    "# Simulating Single Phase Transport \n",
    "\n",
    "The point of an OpenPNM simulation is ultimately to compute some transport process.  In this notebook we will cover the following subjects:\n",
    "\n",
    "| Topics |\n",
    "| :- |\n",
    "| Defining conductance |\n",
    "| Settings boundary conditions |\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cac063b0",
   "metadata": {},
   "source": [
    "Start by defining a network.  We'll use the ``Demo`` class which happens to include all the geometrical pore-scale models already. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 46,
   "id": "94917bac",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "══════════════════════════════════════════════════════════════════════════════\n",
      "net : <openpnm.network.Demo at 0x271c9cacd60>\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Properties                                                   Valid Values\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.coordination_number                                          25 / 25\n",
      "  2  pore.coords                                                       25 / 25\n",
      "  3  pore.diameter                                                     25 / 25\n",
      "  4  pore.max_size                                                     25 / 25\n",
      "  5  pore.seed                                                         25 / 25\n",
      "  6  pore.volume                                                       25 / 25\n",
      "  7  throat.conns                                                      40 / 40\n",
      "  8  throat.cross_sectional_area                                       40 / 40\n",
      "  9  throat.diameter                                                   40 / 40\n",
      " 10  throat.diffusive_size_factors                                     40 / 40\n",
      " 11  throat.hydraulic_size_factors                                     40 / 40\n",
      " 12  throat.length                                                     40 / 40\n",
      " 13  throat.max_size                                                   40 / 40\n",
      " 14  throat.spacing                                                    40 / 40\n",
      " 15  throat.volume                                                     40 / 40\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Labels                                                 Assigned Locations\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.all                                                               25\n",
      "  2  pore.back                                                               5\n",
      "  3  pore.front                                                              5\n",
      "  4  pore.left                                                               5\n",
      "  5  pore.right                                                              5\n",
      "  6  pore.surface                                                           16\n",
      "  7  throat.all                                                             40\n",
      "  8  throat.surface                                                         16\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
     ]
    }
   ],
   "source": [
    "import numpy as np\n",
    "import openpnm as op\n",
    "pn = op.network.Demo(shape=[5, 5, 1], spacing=5e-5)\n",
    "print(pn)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "a7a0902f",
   "metadata": {},
   "source": [
    "## Define Phase Viscosity\n",
    "\n",
    "To fully illustrate the process of performing transport calculations, we'll use an empty ``Phase`` object and add all the needed properties manually:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 47,
   "id": "b5e3a75a",
   "metadata": {},
   "outputs": [],
   "source": [
    "water = op.phase.Phase(network=pn)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b8973bf1",
   "metadata": {},
   "source": [
    "Let's assume that we are interested in pressure driven flow. This requires knowing the viscosity of the phase, so let's add a pore-scale model for computing the viscosity of water:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 48,
   "id": "029d1797",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "══════════════════════════════════════════════════════════════════════════════\n",
      "phase_01 : <openpnm.phase.Phase at 0x271c9cbd9f0>\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Properties                                                   Valid Values\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.pressure                                                     25 / 25\n",
      "  2  pore.temperature                                                  25 / 25\n",
      "  3  pore.viscosity                                                    25 / 25\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Labels                                                 Assigned Locations\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.all                                                               25\n",
      "  2  throat.all                                                             40\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
     ]
    }
   ],
   "source": [
    "water.add_model(propname='pore.viscosity',\n",
    "                model=op.models.phase.viscosity.water_correlation)\n",
    "print(water)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "21aab8de",
   "metadata": {},
   "source": [
    "And we can check the individual values to verify they make sense:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 49,
   "id": "8833d1ee",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[0.00089319 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319\n",
      " 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319\n",
      " 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319\n",
      " 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319 0.00089319\n",
      " 0.00089319]\n"
     ]
    }
   ],
   "source": [
    "print(water['pore.viscosity'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "95ba0972",
   "metadata": {},
   "source": [
    "## Basic Conductance Calculation\n",
    "\n",
    "Determining the conductance of the conduits between each pair of connected pores is the most important part of performing a simulation. The details of conductance models are covered elsewhere. [](XXX)  For this demonstration will assume the very simplest case where all pressure loss occurs in the throats.\n",
    "\n",
    "Recall the Hagan-Poiseuille equation for fluid flow through a cylindrical tube:\n",
    "\n",
    "$$ Q = \\frac{\\pi R^4}{8 \\mu L} \\Delta P$$\n",
    "\n",
    "where $R$ and $L$ are the radius and length of the throat, and $\\mu$ is the viscosity of the fluid.  Together this prefactor can be referred to as the hydraulic conductance, $g_h$, giving:\n",
    "\n",
    "$$ Q = g_h \\Delta P $$\n",
    "\n",
    "So the aim is the compute values of $g_h$ for each throat.  We start by doing this manually:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 50,
   "id": "647bde31",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[4.07871382e-15 2.62488557e-15 2.49650596e-15 8.64316529e-16\n",
      " 1.52364703e-15 6.80412134e-15 7.28698615e-15 2.96891403e-14\n",
      " 2.06628669e-15 7.43597321e-14 9.14007428e-15 9.36831469e-15\n",
      " 2.28178331e-14 1.86746628e-14 1.28418216e-14 7.43505687e-15\n",
      " 9.52724697e-16 8.89047656e-16 1.74003283e-14 1.18269681e-14\n",
      " 1.21481798e-15 5.26904727e-14 2.19091470e-15 3.60997390e-14\n",
      " 8.48775132e-16 1.16849657e-15 6.80252617e-14 6.88544696e-15\n",
      " 9.68594576e-15 2.86012289e-14 1.78574478e-15 3.62521865e-14\n",
      " 2.05700098e-14 7.68471332e-15 9.05860716e-15 2.33843351e-14\n",
      " 9.34621654e-16 1.70132562e-14 1.31241221e-14 7.36657361e-15]\n"
     ]
    }
   ],
   "source": [
    "R = pn['throat.diameter']/2\n",
    "L = pn['throat.length']\n",
    "mu = water['throat.viscosity']  # See ProTip below\n",
    "water['throat.hydraulic_conductance'] = np.pi*R**4/(8*mu*L)\n",
    "print(water['throat.hydraulic_conductance'])"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7720d25b",
   "metadata": {},
   "source": [
    "----\n",
    "> 💡 **ProTip!** \n",
    ">\n",
    "> The ``Phase`` class has a special ability to interpolate pore values to throats, and vice-versa. In PNM simulations all the balances are solved for each pore, so the thermodynamic properties like temperature, pressure, etc. are all defined on pores. Consequently, the physical properties are also defined in pores, like viscosity. However, as shown above we often want viscosity values in the throats. OpenPNM provides a shortcut for this, such that if you request a throat property that does not exist, it will attempt to fetch the pores values and do a linear interpolation of values to produce an array of throat values.  There is also a function for this, ``water.interpolate_data('throat.viscosity')``, but the ``water['throat.viscosity']`` shortcut is very convenient."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "id": "d4544d8b",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319])"
      ]
     },
     "execution_count": 51,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water.interpolate_data('throat.viscosity')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 52,
   "id": "cf30019f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319,\n",
       "       0.00089319, 0.00089319, 0.00089319, 0.00089319, 0.00089319])"
      ]
     },
     "execution_count": 52,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water['throat.viscosity']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6e71e725",
   "metadata": {},
   "source": [
    "## Create Algorithm Object\n",
    "\n",
    "OpenPNM contains a variety of ``Algorithm`` classes in the ``openpnm.algorithms`` module.  Let's initialize a ``StokesFlow`` algorithm, since this simulates pressure driven flow through the network. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 53,
   "id": "29b8bf9d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "══════════════════════════════════════════════════════════════════════════════\n",
      "stokes_01 : <openpnm.algorithms.StokesFlow at 0x271c9ce1680>\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Properties                                                   Valid Values\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.bc.rate                                                       0 / 25\n",
      "  2  pore.bc.value                                                      0 / 25\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Labels                                                 Assigned Locations\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.all                                                               25\n",
      "  2  throat.all                                                             40\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
     ]
    }
   ],
   "source": [
    "sf = op.algorithms.StokesFlow(network=pn, phase=water)\n",
    "print(sf)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "72c4d6c8",
   "metadata": {},
   "source": [
    "## Assign Boundary Conditions\n",
    "\n",
    "As can be seen in the print-out above there are predefined ``'pore.bc'`` arrays, but they contain no valid values, meaning they are all ``nans``. Once we set some boundary conditions, this will change.  Let's apply pressure BCs on one side of the network, and rate BCs on the other:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 54,
   "id": "3caad7c7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "══════════════════════════════════════════════════════════════════════════════\n",
      "stokes_01 : <openpnm.algorithms.StokesFlow at 0x271c9ce1680>\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Properties                                                   Valid Values\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.bc.rate                                                       5 / 25\n",
      "  2  pore.bc.value                                                      5 / 25\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Labels                                                 Assigned Locations\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.all                                                               25\n",
      "  2  throat.all                                                             40\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
     ]
    }
   ],
   "source": [
    "sf.set_value_BC(pores=pn.pores('left'), values=100_000)\n",
    "sf.set_rate_BC(pores=pn.pores('right'), rates=1e-10)\n",
    "print(sf)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7114b180",
   "metadata": {},
   "source": [
    "Now we can see there are 5 valid values of each type.  The ``sf`` algorithm will look for ``'throat.hydraulic_conductance'`` on ``water`` by default, so we can just ``run``:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "732f855a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                                                                                                                       \r"
     ]
    }
   ],
   "source": [
    "soln = sf.run()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "613df06f",
   "metadata": {},
   "source": [
    "The ``run`` method solves the mass balance around each pore and computes the pressure within each pore that is required to sustain the flow defined by the boundary conditions.  The ``soln`` object that is returned is a dictionary with the key corresponding to the quantity that was solved for.  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 56,
   "id": "cf47340a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "{'pore.pressure': SteadyStateSolution([100000.        , 100000.        , 100000.        ,\n",
      "                     100000.        , 100000.        , 106210.27050397,\n",
      "                     105849.95521037, 106589.7947894 , 104530.53233244,\n",
      "                     107340.02831631, 113136.55666764, 110299.0958055 ,\n",
      "                     111597.08824878, 111255.08964542, 110474.21371183,\n",
      "                     120951.97877039, 115823.52328237, 118117.34361488,\n",
      "                     120276.02424136, 119562.37275159, 126553.01853668,\n",
      "                     159066.70359773, 126889.12984693, 128074.69654368,\n",
      "                     130017.71158255])}\n"
     ]
    }
   ],
   "source": [
    "print(soln)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bd75fd50",
   "metadata": {},
   "source": [
    "The reason for the dict format is to provide a consistent API for single components and multiphysics, where multiple different quanties might be solved for.  However, these ``'pore.pressure'`` values are also written to the dictionary of the algorithm object as well:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 57,
   "id": "520819ef",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "══════════════════════════════════════════════════════════════════════════════\n",
      "stokes_01 : <openpnm.algorithms.StokesFlow at 0x271c9ce1680>\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Properties                                                   Valid Values\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.bc.rate                                                       5 / 25\n",
      "  2  pore.bc.value                                                      5 / 25\n",
      "  3  pore.initial_guess                                                25 / 25\n",
      "  4  pore.pressure                                                     25 / 25\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Labels                                                 Assigned Locations\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.all                                                               25\n",
      "  2  throat.all                                                             40\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
     ]
    }
   ],
   "source": [
    "print(sf)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc617629",
   "metadata": {},
   "source": [
    "Finally we can look at how much pressure was required in the \"right\" pores to meet the required flow rate:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "id": "16a3d0d8",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([126553.01853668, 159066.70359773, 126889.12984693, 128074.69654368,\n",
       "       130017.71158255])"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sf['pore.pressure'][pn.pores('right')]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "55cc13bb",
   "metadata": {},
   "source": [
    "So we can see that 13 kPa was required to accomplish the requested flow. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "73b9cba6",
   "metadata": {},
   "source": [
    "## Rigorous Conductance Calculation: Manual Method\n",
    "\n",
    "The above demonstration used a very simplistic conductance calculation.  It was also stated that computing conductance is the most important part of doing a PNM simulation.  To finish this notebook, we'll look more closely at this process."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "adaba0f7",
   "metadata": {},
   "source": [
    "Let's print the network object again:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 63,
   "id": "322b2746",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "══════════════════════════════════════════════════════════════════════════════\n",
      "net : <openpnm.network.Demo at 0x271c9cacd60>\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Properties                                                   Valid Values\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.coordination_number                                          25 / 25\n",
      "  2  pore.coords                                                       25 / 25\n",
      "  3  pore.diameter                                                     25 / 25\n",
      "  4  pore.max_size                                                     25 / 25\n",
      "  5  pore.seed                                                         25 / 25\n",
      "  6  pore.volume                                                       25 / 25\n",
      "  7  throat.conns                                                      40 / 40\n",
      "  8  throat.cross_sectional_area                                       40 / 40\n",
      "  9  throat.diameter                                                   40 / 40\n",
      " 10  throat.diffusive_size_factors                                     40 / 40\n",
      " 11  throat.hydraulic_size_factors                                     40 / 40\n",
      " 12  throat.length                                                     40 / 40\n",
      " 13  throat.max_size                                                   40 / 40\n",
      " 14  throat.spacing                                                    40 / 40\n",
      " 15  throat.volume                                                     40 / 40\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  #  Labels                                                 Assigned Locations\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n",
      "  1  pore.all                                                               25\n",
      "  2  pore.back                                                               5\n",
      "  3  pore.front                                                              5\n",
      "  4  pore.left                                                               5\n",
      "  5  pore.right                                                              5\n",
      "  6  pore.surface                                                           16\n",
      "  7  throat.all                                                             40\n",
      "  8  throat.surface                                                         16\n",
      "――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――\n"
     ]
    }
   ],
   "source": [
    "print(pn)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "9f10eed9",
   "metadata": {},
   "source": [
    "Note the ``'throat.hydraulic_size_factors'`` array.  This is computed by a pore-scale model on the ``Demo`` network.  This computation is more rigorous in the following ways:\n",
    "\n",
    "1. The conductance of each half pore and that throat is considered.\n",
    "1. The throat length is computed carefully by accounting for the 'lens' between the intersection of the spherical pore bodies and the cylindrical throat.\n",
    "1. The net cross-sectional area of the pores are computed by integrating between the pore center and the pore-throat intersection point\n",
    "\n",
    "The conductance of each element in the conduit is returned as an *Nt-by-3* array, where columns 1 and 3 contain the hydraulic conductance of the half pore on either end of the throat, and the column 1 contains the throat conductance."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 60,
   "id": "65e69a58",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[8.71374824e-17, 3.64307026e-18, 1.69476709e-16],\n",
       "       [1.39107321e-16, 2.34452403e-18, 6.35649123e-17],\n",
       "       [6.35649123e-17, 2.22985652e-18, 1.23583518e-16],\n",
       "       [7.63303754e-17, 7.71999699e-19, 2.95278044e-17],\n",
       "       [4.22927679e-17, 1.36090773e-18, 1.12938944e-16],\n",
       "       [2.21058166e-16, 6.07737959e-18, 1.23253419e-16],\n",
       "       [1.23253419e-16, 6.50867006e-18, 2.49810123e-16],\n",
       "       [4.59253634e-16, 2.65180714e-17, 3.27922318e-16],\n",
       "       [5.09514999e-17, 1.84558857e-18, 1.38817555e-16],\n",
       "       [6.65404041e-16, 6.64174396e-17, 6.23438780e-16],\n",
       "       [2.56148448e-16, 8.16383161e-18, 1.50558689e-16],\n",
       "       [1.50558689e-16, 8.36769388e-18, 2.67735776e-16],\n",
       "       [3.06086072e-16, 2.03806820e-17, 3.31572166e-16],\n",
       "       [3.03338786e-16, 1.66800397e-17, 2.65843221e-16],\n",
       "       [2.30436485e-16, 1.14701988e-17, 2.12521168e-16],\n",
       "       [1.68159063e-16, 6.64092549e-18, 1.47038361e-16],\n",
       "       [8.35046328e-17, 8.50965075e-19, 3.11945583e-17],\n",
       "       [3.11945583e-17, 7.94089318e-19, 6.89632875e-17],\n",
       "       [2.59529241e-16, 1.55418157e-17, 2.75754206e-16],\n",
       "       [2.32011520e-16, 1.05637408e-17, 1.97388609e-16],\n",
       "       [5.52390810e-17, 1.08506442e-18, 4.22927679e-17],\n",
       "       [5.14618757e-16, 4.70626532e-17, 5.39513914e-16],\n",
       "       [6.35649123e-17, 1.95690518e-18, 8.11444803e-17],\n",
       "       [3.75030725e-16, 3.22439601e-17, 4.99218077e-16],\n",
       "       [2.95278044e-17, 7.58118265e-19, 7.26505546e-17],\n",
       "       [4.22927679e-17, 1.04369056e-18, 4.52317402e-17],\n",
       "       [5.86908100e-16, 6.07595480e-17, 6.40406667e-16],\n",
       "       [1.23253419e-16, 6.15001890e-18, 2.26148519e-16],\n",
       "       [2.83069647e-16, 8.65139907e-18, 1.50558689e-16],\n",
       "       [3.27922318e-16, 2.55463588e-17, 4.34281587e-16],\n",
       "       [5.09514999e-17, 1.59501107e-18, 9.97337772e-17],\n",
       "       [4.89086914e-16, 3.23801248e-17, 3.81887347e-16],\n",
       "       [3.64636765e-16, 1.83729465e-17, 2.65843221e-16],\n",
       "       [1.50558689e-16, 6.86391637e-18, 1.70681697e-16],\n",
       "       [2.63820422e-16, 8.09106591e-18, 1.47038361e-16],\n",
       "       [3.06086072e-16, 2.08866764e-17, 3.48099174e-16],\n",
       "       [7.95558304e-17, 8.34795601e-19, 3.11945583e-17],\n",
       "       [2.61763625e-16, 1.51960864e-17, 2.59529241e-16],\n",
       "       [2.12521168e-16, 1.17223470e-17, 2.43029032e-16],\n",
       "       [1.47038361e-16, 6.57975686e-18, 1.63626402e-16]])"
      ]
     },
     "execution_count": 60,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pn['throat.hydraulic_size_factors']"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "29f6fccb",
   "metadata": {},
   "source": [
    "This data is called the ``size factor`` because it is purely the geometrical information required for the computation of the hydraulic conductance.  So the Hagan-Poisseiulle equation for each element is written as:\n",
    "\n",
    "$$ Q = \\frac{F_h}{\\mu} \\Delta P = g_h \\Delta P$$\n",
    "\n",
    "Note that both the $\\frac{\\pi R^4}{8}$ term and $L$ are missing, as they now rolled into the $F_h$ value.\n",
    "\n",
    "The total conductance of the pore-throat-pore conduit can be found as the sum of three resistors in series.  Since we have conductance values, we add the inverses, and invert again.  The full expression for the hydraulic conductance between pores i and j, through throat k, is:\n",
    "\n",
    "\n",
    "$$ Q = \\bigg( \\frac{\\mu}{F_{h, i}} + \\frac{\\mu}{F_{h, k}} + \\frac{\\mu}{F_{h, j}} \\bigg) ^ {-1} \\Delta P $$\n",
    "\n",
    "This can be computed by hand:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "id": "0b26948e",
   "metadata": {},
   "outputs": [],
   "source": [
    "F_h = water['throat.hydraulic_size_factors']\n",
    "water['throat.hydraulic_conductance'] = (mu * (1/F_h).sum(axis=1))**(-1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 62,
   "id": "fc49009f",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([3.83588577e-15, 2.49102298e-15, 2.37057327e-15, 8.34074035e-16,\n",
       "       1.45911308e-15, 6.31883354e-15, 6.75432842e-15, 2.60749307e-14,\n",
       "       1.96879675e-15, 6.16403034e-14, 8.41553796e-15, 8.61984356e-15,\n",
       "       2.02276499e-14, 1.67076383e-14, 1.16347406e-14, 6.85475709e-15,\n",
       "       9.18315496e-16, 8.57350807e-16, 1.55882592e-14, 1.07610967e-14,\n",
       "       1.16217262e-15, 4.47028330e-14, 2.07688885e-15, 3.13756412e-14,\n",
       "       8.19194147e-16, 1.11524150e-15, 5.67633404e-14, 6.39262689e-15,\n",
       "       8.90232105e-15, 2.51610116e-14, 1.70509843e-15, 3.14963896e-14,\n",
       "       1.83743003e-14, 7.07743827e-15, 8.34359646e-15, 2.07263836e-14,\n",
       "       9.01053673e-16, 1.52365904e-14, 1.18943332e-14, 6.78971503e-15])"
      ]
     },
     "execution_count": 62,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "water['throat.hydraulic_conductance']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 65,
   "id": "3ef96480",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                                                                                                                       \r"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([130241.87741162, 163598.56582326, 130374.11254203, 131602.86219683,\n",
       "       133644.23156533])"
      ]
     },
     "execution_count": 65,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sf = op.algorithms.StokesFlow(network=pn, phase=water)\n",
    "sf.set_value_BC(pores=pn.pores('left'), values=100_000)\n",
    "sf.set_rate_BC(pores=pn.pores('right'), rates=1e-10)\n",
    "soln = sf.run()\n",
    "sf['pore.pressure'][pn.pores('right')]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "5d59ec79",
   "metadata": {},
   "source": [
    "As can be seen the numbers are about the same as with the simple case, but should be somewhat more correct.  In fact, these above pressures are a bit higher, which is because the total conductance of the conduit is lower due to the inclusion of the pore body lengths into the total length, compared to above where only the throat length was included."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4535fccd",
   "metadata": {},
   "source": [
    "## Rigorous Conductance Calculation: Pore-Scale Model Method\n",
    "\n",
    "Instead of computing the hydraulic conductance manually as done above, there is a pore-scale model available:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "id": "9891436d",
   "metadata": {},
   "outputs": [],
   "source": [
    "water.add_model(propname='throat.hydraulic_conductance',\n",
    "                model=op.models.physics.hydraulic_conductance.generic_hydraulic)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 67,
   "id": "fd34b943",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "                                                                                                                       \r"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([130241.87741162, 163598.56582326, 130374.11254203, 131602.86219683,\n",
       "       133644.23156533])"
      ]
     },
     "execution_count": 67,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sf = op.algorithms.StokesFlow(network=pn, phase=water)\n",
    "sf.set_value_BC(pores=pn.pores('left'), values=100_000)\n",
    "sf.set_rate_BC(pores=pn.pores('right'), rates=1e-10)\n",
    "soln = sf.run()\n",
    "sf['pore.pressure'][pn.pores('right')]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "56ab903f",
   "metadata": {},
   "source": [
    "Which gives exactly the same result, without have to manually deal with the conductances-in-series calculation."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
